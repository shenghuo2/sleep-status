<!DOCTYPE html>
<html lang="zh-CN" class="dark:bg-gray-900">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading...</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'media',
    }
  </script>
  <style>
    .status-sleeping { color: #3498db; }
    .status-awake { color: #2ecc71; }
    .status-error { color: #e74c3c; }
    @media (prefers-color-scheme: dark) {
      .status-sleeping { color: #60a5fa; }
      .status-awake { color: #34d399; }
      .status-error { color: #f87171; }
    }
    .offline-mode {
      transition: all 0.5s ease;
      filter: grayscale(70%) brightness(85%);
    }
    .floating-candle {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      font-size: 2rem;
      filter: drop-shadow(0 0 10px rgba(255, 200, 100, 0.3));
      transition: transform 0.3s ease-out;
    }
    .candle-flame {
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      animation: flicker 1s ease-in-out infinite alternate;
      color: #ffd700;
      text-shadow: 0 0 10px #ff6b00,
                   0 0 20px #ff6b00,
                   0 0 30px #ff8800;
    }

    @keyframes flicker {
      0%, 100% {
        transform: translateX(-50%) scale(1.1);
        text-shadow: 0 0 10px #ff6b00,
                     0 0 20px #ff6b00,
                     0 0 30px #ff8800;
      }
      50% {
        transform: translateX(-50%) scale(0.9);
        text-shadow: 0 0 5px #ff6b00,
                     0 0 10px #ff6b00,
                     0 0 15px #ff8800;
      }

    }
    .offline-mode::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0.3) 0%, transparent 80%),
        linear-gradient(0deg, rgba(0,0,0,0.2) 0%, transparent 100%);
      pointer-events: none;

      z-index: 999;
    }
  </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900" id="mainBody">
  <div id="candleContainer"></div>
  <div class="max-w-2xl mx-auto px-4 py-8">
    <h1 class="text-3xl font-bold mb-8 text-gray-900 dark:text-white"><span id='my-name'>æˆ‘</span><ruby>ä¼¼<rt>sÇ</rt></ruby>äº†å—?</h1>

    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6 transition-shadow duration-300 hover:shadow-xl">
      <div class="text-gray-700 dark:text-gray-300" id="my-status">Loading...</div>
      <div id="status" class="text-2xl my-3">åŠ è½½ä¸­...</div>
      <div id="description" class="text-gray-600 dark:text-gray-400"></div>
      <div class="text-sm text-gray-500 dark:text-gray-400 mt-4">æœ€åæ›´æ–°: <span id="updateTime"></span></div>
    </div>

    <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6 transition-shadow duration-300 hover:shadow-xl">
      <div id="timelineTitle" class="text-gray-700 dark:text-gray-300 mb-4">ç¦»çº¿è®°å½•:</div>
      <div id="sleepTimelines" class="space-y-8"></div>
      <div id="timelineDescription" class="text-sm text-gray-500 dark:text-gray-400 mt-8"></div>
      <div id="weeklyStats" class="mt-8 pt-6 border-t border-gray-200 dark:border-gray-700">
        <div id="statsTitle" class="text-gray-700 dark:text-gray-300 mb-4">ç¡çœ ç»Ÿè®¡:</div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div class="space-y-2">
            <div class="text-sm text-gray-600 dark:text-gray-400">å¹³å‡å…¥ç¡æ—¶é—´: <span id="avgSleepTime" class="font-mono">--:--</span></div>
            <div class="text-sm text-gray-600 dark:text-gray-400">å¹³å‡æ¸…é†’æ—¶é—´: <span id="avgWakeTime" class="font-mono">--:--</span></div>
          </div>
          <div class="space-y-2">
            <div class="text-sm text-gray-600 dark:text-gray-400">æ¯æ—¥å¹³å‡ç¡çœ æ—¶é•¿: <span id="avgSleepDuration" class="font-mono">-å°æ—¶-åˆ†é’Ÿ</span></div>
            <div class="text-sm text-gray-600 dark:text-gray-400">ç»Ÿè®¡å‘¨æœŸ: <span id="statsDateRange" class="font-mono">----/--/-- ~ ----/--/--</span></div>
          </div>
        </div>
      </div>
    </div>

    <div class="flex flex-col space-y-4">

      <div class="flex justify-between items-center">
        <div class="text-sm text-gray-600 dark:text-gray-400">
          ä½ å¯ä»¥é€šè¿‡è¿™ä¸ªé¡µé¢ ğŸ‘€ <span id='my-name1'>æˆ‘</span>
          <br>
        è”ç³»æ–¹å¼ <a href="https://www.google.com" id='contact-me' class="text-blue-500 hover:underline" target="_blank">ç‚¹æˆ‘</a>

        </div>
      </div>
      <div class="text-xs text-gray-500 dark:text-gray-400 border-t pt-4 mt-4">
        æœ¬é¡¹ç›®å±•ç¤º <a href="https://www.google.com" class="text-blue-500 hover:underline" target="_blank" id="my-github"><span id='my-name2'>æˆ‘</span></a> çš„<span id='info-from'></span>
        <br>
        é¡¹ç›®å¼€æºäº <a href="https://github.com/shenghuo2/sleep-status" class="text-blue-500 hover:underline" target="_blank">Github</a>
        <br>
        å‰ç«¯å¼€æºäº <a href="https://github.com/shenghuo2/sleep-status/tree/feature/example-frontend" class="text-blue-500 hover:underline" target="_blank">feature/example-fronend</a> åˆ†æ”¯
      </div>

    </div>

    <script>
	  // =================== é…ç½® ===================
	  const MY_NAME = "shenghuo2";
	  const API_URL = "https://sleep-status.shenghuo2.top";
	  const MY_GITHUB_URL = "https://github.com/shenghuo2";
	  const CONTACT_URL = "https://github.com/shenghuo2";
	  const INFO_FROM = "Xiaomi 14 è®¾å¤‡åœ¨çº¿çŠ¶æ€ï¼Œå¹¶é€šè¿‡Magisk æ¨¡å—å®æ—¶é‡‡é›†å¹¶ä¸Šä¼ ã€‚";
	  // =================== é…ç½® ===================
	  
	  // Init
	  document.title = MY_NAME + 'ç°åœ¨ä¼¼äº†å—?';
	  
	  document.getElementById('my-status').textContent = MY_NAME + "'s Status:";
	  document.getElementById('my-name').textContent = MY_NAME;
	  document.getElementById('my-name1').textContent = MY_NAME;
	  document.getElementById('my-name2').textContent = MY_NAME;
	  document.getElementById('my-github').href = MY_GITHUB_URL;
	  document.getElementById('info-from').textContent = INFO_FROM;
	  document.getElementById('contact-me').href = CONTACT_URL;
	  
	  
      function formatTime(hours) {
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
      }
      
      function formatDuration(hours) {
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
      
            if (h === 0) {
                  return `${m}m`;
            } else {
                  return `${h}h${m > 0 ? m + 'm' : ''}`;
            }
      }
      
      function updateTime() {
            const now = new Date();
      
            return now.getFullYear() + '-' +
                  String(now.getMonth() + 1).padStart(2, '0') + '-' +
                  String(now.getDate()).padStart(2, '0') + ' ' +
                  String(now.getHours()).padStart(2, '0') + ':' +
                  String(now.getMinutes()).padStart(2, '0') + ':' +
                  String(now.getSeconds()).padStart(2, '0');
      }
      
      function createTimelineElement(date, segments) {
            const container = document.createElement('div');
            container.className = 'mb-8 last:mb-0';
      
            const dateLabel = document.createElement('div');
            dateLabel.className = 'text-sm text-gray-600 dark:text-gray-400 mb-2';
            dateLabel.textContent = date;
            container.appendChild(dateLabel);
      
            const timelineWrapper = document.createElement('div');
            timelineWrapper.className = 'relative';
            container.appendChild(timelineWrapper);
      
      
            // æ—¶é—´çº¿å’Œåˆ»åº¦çº¿
            const timelineContainer = document.createElement('div');
            timelineContainer.className = 'relative h-6 bg-gray-100 dark:bg-gray-700 rounded-md overflow-hidden';
            timelineWrapper.appendChild(timelineContainer);
      
            // æ·»åŠ åˆ»åº¦çº¿
      
            for (let hour = 0; hour <= 24; hour += 3) {
                  const tick = document.createElement('div');
                  tick.className = 'absolute top-0 bottom-0 w-px bg-gray-300 dark:bg-gray-600 z-10';
                  tick.style.left = `${(hour / 24) * 100}%`;
      
      
                  // ä¸»è¦åˆ»åº¦çº¿åŠ ç²—
                  if (hour % 6 === 0) {
                        tick.classList.add('bg-gray-400', 'dark:bg-gray-500');
                  }
      
                  timelineContainer.appendChild(tick);
            }
      
            // æ·»åŠ æ—¶é—´åˆ»åº¦
            const timeMarkers = document.createElement('div');
            timeMarkers.className = 'flex justify-between text-xs text-gray-400 dark:text-gray-500 mt-1';
      
      
            // æ·»åŠ 6å°æ—¶é—´éš”çš„åˆ»åº¦
            for (let hour = 0; hour <= 24; hour += 6) {
                  const marker = document.createElement('div');
                  marker.className = 'relative';
                  marker.style.width = '1px'; // ä»…ç”¨äºå®šä½
      
                  // åˆ»åº¦æ–‡æœ¬
                  const text = document.createElement('div');
                  text.className = 'absolute transform -translate-x-1/2';
                  text.textContent = hour === 0 || hour === 24 ? hour : hour;
                  marker.appendChild(text);
      
                  timeMarkers.appendChild(marker);
            }
      
            timelineWrapper.appendChild(timeMarkers);
      
            segments.forEach(segment => {
                  const segmentElement = document.createElement('div');
                  segmentElement.className =
                        'absolute h-full bg-blue-200 dark:bg-blue-800 flex items-center justify-center ' +
                        'text-xs text-gray-600 dark:text-gray-300 transition-all duration-300 z-20';
                  segmentElement.style.left = segment.start + '%';
                  segmentElement.style.width = (segment.end - segment.start) + '%';
      
                  const timeText = document.createElement('div');
                  timeText.className = 'px-2 whitespace-nowrap';
                  timeText.textContent = segment.text;
                  segmentElement.appendChild(timeText);
      
      
                  timelineContainer.appendChild(segmentElement);
            });
      
            return container;
      }
      
      function getDatesBetween(startUTC, endUTC) {
            const start = new Date(startUTC.getTime() + 8 * 60 * 60 * 1000);
            start.setUTCHours(0, 0, 0, 0);
      
            const end = new Date(endUTC.getTime() + 8 * 60 * 60 * 1000);
            end.setUTCHours(23, 59, 59, 999);
      
            const dates = [];
            let current = new Date(start);
      
            while (current <= end) {
                  dates.push(new Date(current));
                  current = new Date(current.getTime() + 24 * 60 * 60 * 1000);
            }
            return dates;
      }
      
      function toLocalISODateString(utcTime) {
            const date = new Date(utcTime);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
      }
      
      
      
      function calculateSleepSegments(records) {
      
            const sleepSegments = {};
      
            const sortedRecords = [...records].sort((a, b) =>
      
                  new Date(a.time) - new Date(b.time)
            );
      
            let currentSleep = null;
      
            sortedRecords.forEach((record) => {
                  const date = new Date(record.time);
                  const localDateStr = toUTC8DateString(record.time);
      
                  // è½¬æ¢ä¸ºUTC+8æ—¶é—´
                  const utc8Date = new Date(date.getTime() + 8 * 60 * 60 * 1000);
                  const hours = utc8Date.getUTCHours() + utc8Date.getUTCMinutes() / 60;
      
                  if (record.action === 'sleep') {
                        currentSleep = {
                              start: date,
                              startHours: hours,
                              startDate: localDateStr
                        };
                  } else if (record.action === 'wake' && currentSleep) {
                        const endDate = new Date(record.time);
                        const endUtc8Date = new Date(endDate.getTime() + 8 * 60 * 60 * 1000);
                        const endHours = endUtc8Date.getUTCHours() + endUtc8Date.getUTCMinutes() / 60;
      
                        const datesBetween = getDatesBetween(
                              new Date(currentSleep.start),
                              new Date(endDate)
                        );
      
                        datesBetween.forEach((dateObj, i) => {
                              const dateKey = dateObj.toISOString().substring(0, 10);
                              if (!sleepSegments[dateKey]) sleepSegments[dateKey] = [];
      
                              const segmentStart = i === 0 ? currentSleep.startHours : 0;
                              const segmentEnd = i === datesBetween.length - 1 ? endHours : 24;
      
                              sleepSegments[dateKey].push({
                                    start: segmentStart,
                                    end: segmentEnd,
                                    text: `${formatTime(segmentStart)}-${formatTime(segmentEnd)} ` +
                                          `(${formatDuration(segmentEnd - segmentStart)})`
                              });
                        });
      
                        currentSleep = null;
                  }
            });
      
            // å¤„ç†æœªç»“æŸçš„ç¡çœ 
            if (currentSleep) {
                  const now = new Date();
                  const datesBetween = getDatesBetween(currentSleep.start, now);
      
                  datesBetween.forEach((dateObj, i) => {
                        const dateKey = dateObj.toISOString().substring(0, 10);
                        if (!sleepSegments[dateKey]) sleepSegments[dateKey] = [];
      
                        const segmentStart = i === 0 ? currentSleep.startHours : 0;
                        const segmentEnd = i === datesBetween.length - 1 ?
                              (now.getHours() + now.getMinutes() / 60) : 24;
      
      
                        sleepSegments[dateKey].push({
      
                              start: segmentStart,
                              end: segmentEnd,
                              text: `${formatTime(segmentStart)}-${formatTime(segmentEnd)} ` +
                                    `(${formatDuration(segmentEnd - segmentStart)})`
                        });
                  });
            }
      
            return sleepSegments;
      }
      
      
      function createFloatingElements(sleep) {
            const candleContainer = document.getElementById('candleContainer');
      
            let candleAnimationFrame;
      
            // æ¸…é™¤ç°æœ‰çš„å…ƒç´ å’ŒåŠ¨ç”»
            candleContainer.innerHTML = '';
      
            if (candleAnimationFrame) {
                  cancelAnimationFrame(candleAnimationFrame);
            }
      
            if (sleep) {
                  // åˆ›å»ºèœ¡çƒ›
      
                  const candles = [];
                  const candleCount = 4;
      
                  for (let i = 0; i < candleCount; i++) {
                        const candleDiv = document.createElement('div');
                        candleDiv.className = 'floating-candle';
      
                        // æ·»åŠ ç«ç„°
                        const flame = document.createElement('div');
                        flame.className = 'candle-flame';
                        flame.textContent = 'ğŸ”¥';
                        candleDiv.appendChild(flame);
      
                        // æ·»åŠ èœ¡çƒ›
      
                        const candle = document.createElement('div');
                        candle.textContent = 'ğŸ•¯ï¸';
                        candleDiv.appendChild(candle);
      
                        candleContainer.appendChild(candleDiv);
      
                        // åˆå§‹ä½ç½®å’Œé€Ÿåº¦
                        const speed = 2;
                        candles.push({
                              element: candleDiv,
                              x: Math.random() * (window.innerWidth - 50),
                              y: Math.random() * (window.innerHeight - 50),
                              dx: (Math.random() - 0.5) * speed,
                              dy: (Math.random() - 0.5) * speed,
                              width: 50,
                              height: 80
                        });
                  }
      
                  // åŠ¨ç”»å‡½æ•°
                  function animateCandles() {
                        candles.forEach(candle => {
                              candle.x += candle.dx;
                              candle.y += candle.dy;
      
                              if (candle.x <= 0 || candle.x >= window.innerWidth - candle.width) {
                                    candle.dx *= -1;
                                    candle.dy += (Math.random() - 0.5) * 0.5;
                              }
                              if (candle.y <= 0 || candle.y >= window.innerHeight - candle.height) {
                                    candle.dy *= -1;
                                    candle.dx += (Math.random() - 0.5) * 0.5;
                              }
      
                              const maxSpeed = 3;
                              const speed = Math.sqrt(candle.dx * candle.dx + candle.dy * candle.dy);
                              if (speed > maxSpeed) {
                                    candle.dx = (candle.dx / speed) * maxSpeed;
                                    candle.dy = (candle.dy / speed) * maxSpeed;
                              }
      
                              candle.element.style.transform = `translate(${candle.x}px, ${candle.y}px)`;
                        });
      
      
                        candleAnimationFrame = requestAnimationFrame(animateCandles);
                  }
      
                  animateCandles();
      
                  window.addEventListener('resize', () => {
                        candles.forEach(candle => {
                              candle.x = Math.min(candle.x, window.innerWidth - candle.width);
                              candle.y = Math.min(candle.y, window.innerHeight - candle.height);
                        });
                  });
      
            }
      }
      
      function updateStatus() {
            fetch(API_URL + '/status')
      
                  .then(response => {
                        if (!response.ok) {
                              throw new Error('ç½‘ç»œå“åº”ä¸æ­£å¸¸: ' + response.statusText);
                        }
                        return response.json();
                  })
                  .then(data => {
                        const statusDiv = document.getElementById('status');
                        const descDiv = document.getElementById('description');
                        const mainBody = document.getElementById('mainBody');
                        console.log('å“åº”æ•°æ®:', data);
      
                        if (data.sleep !== undefined) {
                              updateUIState(data.sleep);
                        } else {
                              throw new Error('æ— æ•ˆçš„æ•°æ®æ ¼å¼');
                        }
      
                        document.getElementById('updateTime').textContent = updateTime();
                  })
                  .catch(error => {
                        console.error('è·å–çŠ¶æ€å¤±è´¥:', error);
                        const statusDiv = document.getElementById('status');
                        statusDiv.textContent = 'è·å–çŠ¶æ€å¤±è´¥ âŒ';
                        statusDiv.className = 'text-2xl my-3 status-error';
                        document.getElementById('description').textContent = error.toString();
                        document.getElementById('updateTime').textContent = updateTime();
                  });
      }
      
      function updateUIState(sleep) {
            const statusDiv = document.getElementById('status');
            const descDiv = document.getElementById('description');
            const mainBody = document.getElementById('mainBody');
      
            if (sleep) {
                  statusDiv.textContent = 'ä¼¼äº† ğŸ˜´';
                  statusDiv.className = 'text-2xl my-3 status-sleeping';
                  descDiv.textContent = 'ç›®å‰æ–­ç½‘äº†ï¼Œé™¤äº†ç”µè¯å¤§æ¦‚éƒ½è”ç³»ä¸ä¸Š';
                  mainBody.classList.add('offline-mode');
                  document.documentElement.classList.add('dark');
                  createFloatingElements(true);
            } else {
                  statusDiv.textContent = 'æ´»ç€ ğŸŒ';
                  statusDiv.className = 'text-2xl my-3 status-awake';
                  descDiv.textContent = 'ç›®å‰åœ¨çº¿ï¼Œå¯ä»¥é€šè¿‡ä»»ä½•å¯ç”¨çš„è”ç³»æ–¹å¼è”ç³»æœ¬äººã€‚';
                  mainBody.classList.remove('offline-mode');
                  document.documentElement.classList.remove('dark');
                  createFloatingElements(false);
            }
      }
      
      
      function toUTC8DateString(utcTime) {
            const date = new Date(utcTime);
            const utc8 = new Date(date.getTime() + 8 * 60 * 60 * 1000);
            return utc8.toISOString().substring(0, 10); // YYYY-MM-DD
      }
      
      function updateWeeklyStats(records, recentDates) {
            const defaultStats = {
      
                  avgSleepTime: '--:--',
                  avgWakeTime: '--:--',
                  avgSleepDuration: '-å°æ—¶-åˆ†é’Ÿ',
                  dateRange: 'æ— æ•°æ®'
            };
      
            // æ¸…ç©ºé»˜è®¤å€¼
            if (!records || records.length < 2 || !recentDates || recentDates.length === 0) {
                  Object.entries(defaultStats).forEach(([id, value]) => {
                        document.getElementById(id).textContent = value;
                  });
                  return;
            }
      
            // æŒ‰æ—¶é—´æ’åºï¼ˆæ—§â†’æ–°ï¼‰
      
            const sortedRecords = [...records].sort((a, b) =>
                  new Date(a.time) - new Date(b.time)
            );
      
            const dailySleepData = {};
            let totalSleepMinutes = 0;
            let totalWakeMinutes = 0;
            let primarySleepCount = 0;
            const now = new Date();
      
            // å¤„ç†æ¯ä¸ªç¡çœ å‘¨æœŸ
            for (let i = 0; i < sortedRecords.length - 1; i++) {
                  const current = sortedRecords[i];
                  const next = sortedRecords[i + 1];
      
                  if (current.action === 'sleep' && next.action === 'wake') {
                        // è½¬æ¢ä¸ºUTC+8æ—¶é—´
                        const sleepTime = new Date(current.time);
                        const wakeTime = new Date(next.time);
      
                        // UTC+8æ—¥æœŸå¤„ç†
                        const sleepDateUTC8 = toUTC8DateString(current.time);
                        const wakeDateUTC8 = toUTC8DateString(next.time);
      
                        // è®¡ç®—UTC+8çš„æ—¶é—´æ•°å€¼
                        const sleepUTCHours = sleepTime.getUTCHours() + 8;
                        const sleepHours = (sleepUTCHours >= 24 ? sleepUTCHours - 24 : sleepUTCHours);
                        const sleepStartHours = sleepHours + sleepTime.getUTCMinutes() / 60;
      
      
                        const wakeUTCHours = wakeTime.getUTCHours() + 8;
                        const wakeHours = (wakeUTCHours >= 24 ? wakeUTCHours - 24 : wakeUTCHours);
                        const wakeEndHours = wakeHours + wakeTime.getUTCMinutes() / 60;
      
                        // è·å–UTC+8çš„æ—¥æœŸèŒƒå›´
                        const dates = getDatesBetween(sleepTime, wakeTime);
      
                        // å¤„ç†æ¯æ—¥ç¡çœ åˆ†å¸ƒ
                        dates.forEach((dateObj, index) => {
                              const dateKey = dateObj.toISOString().split('T')[0];
      
                              if (!dailySleepData[dateKey]) {
                                    dailySleepData[dateKey] = {
                                          total: 0,
                                          primarySleep: null,
                                          wakeTimes: []
                                    };
                              }
      
      
                              // è®¡ç®—å½“å¤©UTC+8æ—¶é—´èŒƒå›´
                              const dayStart = new Date(dateObj);
                              dayStart.setUTCHours(-8, 0, 0, 0); // UTC+8çš„00:00
                              const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
      
                              // è®¡ç®—æœ‰æ•ˆç¡çœ æ—¶é—´æ®µ
                              const effectiveStart = Math.max(sleepTime, dayStart);
                              const effectiveEnd = Math.min(wakeTime, dayEnd);
                              const duration = Math.round((effectiveEnd - effectiveStart) / (60 * 1000));
      
                              if (duration > 0) {
                                    dailySleepData[dateKey].total += duration;
      
                                    // è®°å½•ä¸»è¦ç¡çœ ï¼ˆæ¯å¤©ç¬¬ä¸€ä¸ªè¶…è¿‡3å°æ—¶çš„æ—¶æ®µï¼‰
                                    if (!dailySleepData[dateKey].primarySleep && duration >= 180) {
                                          dailySleepData[dateKey].primarySleep = {
                                                sleepStart: sleepStartHours,
                                                wakeEnd: wakeEndHours,
                                                duration: duration
                                          };
                                    }
                              }
                        });
                  }
            }
      
            // å¤„ç†å½“å‰è¿›è¡Œä¸­çš„ç¡çœ 
      
            const lastRecord = sortedRecords[sortedRecords.length - 1];
            if (lastRecord.action === 'sleep') {
      
                  const sleepTime = new Date(lastRecord.time);
      
                  const dates = getDatesBetween(sleepTime, now);
      
                  dates.forEach(dateObj => {
                        const dateKey = dateObj.toISOString().split('T')[0];
                        if (!dailySleepData[dateKey]) {
                              dailySleepData[dateKey] = {
                                    total: 0,
                                    primarySleep: null,
                                    wakeTimes: []
                              };
                        }
      
                        // UTC+8æ—¶é—´è®¡ç®—
                        const dayStart = new Date(dateObj);
                        dayStart.setUTCHours(-8, 0, 0, 0);
                        const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
      
                        const effectiveStart = sleepTime > dayStart ? sleepTime : dayStart;
                        const effectiveEnd = now < dayEnd ? now : dayEnd;
                        const duration = Math.round((effectiveEnd - effectiveStart) / (60 * 1000));
      
                        if (duration > 0) {
                              dailySleepData[dateKey].total += duration;
                        }
                  });
            }
      
            // è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
            Object.entries(dailySleepData).forEach(([date, data]) => {
                  if (data.primarySleep) {
                        // UTC+8æ—¶é—´è½¬æ¢
                        totalSleepMinutes += data.primarySleep.sleepStart * 60;
                        totalWakeMinutes += data.primarySleep.wakeEnd * 60;
                        primarySleepCount++;
                  }
            });
      
            // è®¡ç®—å¹³å‡å€¼
            const avgSleep = primarySleepCount > 0 ? totalSleepMinutes / primarySleepCount : 0;
            const avgWake = primarySleepCount > 0 ? totalWakeMinutes / primarySleepCount : 0;
      
            // æ ¼å¼åŒ–ä¸ºUTC+8æ—¶é—´
            const avgSleepTime = primarySleepCount > 0 ?
                  formatTime(avgSleep / 60) :
                  defaultStats.avgSleepTime;
      
            const avgWakeTime = primarySleepCount > 0 ?
                  formatTime(avgWake / 60) :
                  defaultStats.avgWakeTime;
      
            // è®¡ç®—æ€»ç¡çœ æ—¶é•¿
            const totalHours = Object.values(dailySleepData)
                  .reduce((sum, day) => sum + day.total, 0) / 60;
            const avgDaily = recentDates.length > 0 ? totalHours / recentDates.length : 0;
      
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('avgSleepTime').textContent = avgSleepTime;
            document.getElementById('avgWakeTime').textContent = avgWakeTime;
      
            document.getElementById('avgSleepDuration').textContent =
                  formatDuration(avgDaily) || defaultStats.avgSleepDuration;
      
            // æ—¥æœŸèŒƒå›´æ˜¾ç¤ºï¼ˆUTC+8ï¼‰
            if (recentDates.length > 0) {
                  const start = recentDates[recentDates.length - 1].replace(/-/g, '/');
                  const end = recentDates[0].replace(/-/g, '/');
                  document.getElementById('statsDateRange').textContent =
                        `${start} ~ ${end}`;
            } else {
                  document.getElementById('statsDateRange').textContent = defaultStats.dateRange;
            }
      }
      
      function updateSleepTimelines() {
            fetch(API_URL + '/records')
                  .then(response => {
                        if (!response.ok) {
                              throw new Error('ç½‘ç»œå“åº”ä¸æ­£å¸¸');
                        }
                        return response.json();
                  })
                  .then(data => {
                        if (!data.success || !Array.isArray(data.records)) {
                              throw new Error('æ— æ•ˆçš„æ•°æ®æ ¼å¼');
                        }
      
      
                        const container = document.getElementById('sleepTimelines');
                        container.innerHTML = '';
      
                        // å¤„ç†æ—¶é—´çº¿æ˜¾ç¤º
      
                        const sleepSegments = calculateSleepSegments(data.records);
                        const allDates = Object.keys(sleepSegments).sort().reverse();
      
                        // æ‰¾å‡ºæœ€è¿‘è¿ç»­çš„æ—¥æœŸï¼ˆå…è®¸æœ€å¤§é—´éš”ä¸º3å¤©ï¼‰
                        const recentContinuousDates = [];
                        const maxDayGap = 3; // å…è®¸çš„æœ€å¤§æ—¥æœŸé—´éš”ï¼ˆå¤©ï¼‰
      
                        if (allDates.length > 0) {
                              recentContinuousDates.push(allDates[0]);
      
                              for (let i = 1; i < allDates.length; i++) {
                                    const currentDate = new Date(allDates[i]);
                                    const previousDate = new Date(allDates[i - 1]);
      
                                    // è®¡ç®—æ—¥æœŸé—´éš”ï¼ˆå¤©æ•°ï¼‰
                                    const daysBetween = Math.round(
                                          (previousDate - currentDate) / (24 * 60 * 60 * 1000)
                                    );
      
                                    // å¦‚æœæ—¥æœŸé—´éš”è¶…è¿‡å…è®¸çš„æœ€å¤§é—´éš”ï¼Œåœæ­¢æ”¶é›†
                                    if (daysBetween > maxDayGap) {
                                          break;
                                    }
      
                                    recentContinuousDates.push(allDates[i]);
      
                                    // æœ€å¤šæ˜¾ç¤º7å¤©
                                    if (recentContinuousDates.length >= 7) {
                                          break;
                                    }
                              }
                        }
      
                        // æ˜¾ç¤ºæ—¶é—´çº¿
      
                        recentContinuousDates.forEach(date => {
                              const segments = sleepSegments[date].map(segment => ({
                                    start: segment.start * 100 / 24,
                                    end: segment.end * 100 / 24,
                                    text: `${formatTime(segment.start)}-${formatTime(segment.end)} (${formatDuration(segment.end - segment.start)})`
                              }));
                              const timeline = createTimelineElement(date, segments);
                              container.appendChild(timeline);
                        });
      
                        // æ›´æ–°ç»Ÿè®¡æ•°æ®ï¼Œä¼ å…¥è¿ç»­æ—¥æœŸæ•°ç»„ï¼Œç¡®ä¿ç»Ÿè®¡ä¸æ˜¾ç¤ºçš„æ—¥æœŸèŒƒå›´ä¸€è‡´
                        updateWeeklyStats(data.records, recentContinuousDates);
      
                        // æ›´æ–°æ—¶é—´çº¿æ ‡é¢˜å’Œæè¿°
      
                        const timelineTitle = document.getElementById('timelineTitle');
                        if (timelineTitle) {
                              if (recentContinuousDates.length === 0) {
                                    timelineTitle.textContent = 'ç¦»çº¿è®°å½•:';
                              } else if (recentContinuousDates.length === 1) {
                                    timelineTitle.textContent = 'å•æ—¥ç¦»çº¿è®°å½•:';
                              } else {
                                    timelineTitle.textContent = `è¿‘${recentContinuousDates.length}å¤©ç¦»çº¿è®°å½•:`;
                              }
                        }
      
                        // æ›´æ–°æ—¶é—´çº¿æè¿°
                        if (recentContinuousDates.length === 0) {
                              document.getElementById('timelineDescription').textContent = 'æš‚æ— ç¦»çº¿è®°å½•';
                        } else if (recentContinuousDates.length === 1) {
                              document.getElementById('timelineDescription').textContent = `æ˜¾ç¤º ${recentContinuousDates[0]} çš„ç¦»çº¿è®°å½•`;
                        } else {
                              const oldestDate = recentContinuousDates[recentContinuousDates.length - 1];
                              const newestDate = recentContinuousDates[0];
                              document.getElementById('timelineDescription').textContent =
                                    `æ˜¾ç¤º ${oldestDate} è‡³ ${newestDate} çš„ç¦»çº¿è®°å½•`;
                        }
                  })
      
                  .catch(error => {
                        console.error('è·å–è®°å½•å¤±è´¥:', error);
                        document.getElementById('timelineDescription').textContent =
                              'è·å–è®°å½•å¤±è´¥: ' + error.toString();
                  });
      }
      
      document.addEventListener("DOMContentLoaded", () => {
            updateStatus();
            updateSleepTimelines();
      
      
            // æ·»åŠ æµ‹è¯•æŒ‰é’®äº‹ä»¶
            const testButton = document.getElementById('testButton');
            let testMode = false;
            testButton.addEventListener('click', () => {
                  testMode = !testMode;
                  updateUIState(testMode);
            });
      });
      
      setInterval(updateStatus, 60000);
      setInterval(updateSleepTimelines, 300000);
    </script>
  </div>
</body>
</html>
